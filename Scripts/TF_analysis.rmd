```{r LIBRARIES, echo=FALSE, message=FALSE, warning=FALSE}
# nolint start
library(pacman)
p_load(GenomicRanges, ggplot2, rtracklayer, dplyr, plyranges, ChIPseeker,
TxDb.Mmusculus.UCSC.mm10.knownGene, TxDb.Hsapiens.UCSC.hg38.knownGene,
BSgenome.Mmusculus.UCSC.mm10, BSgenome.Hsapiens.UCSC.hg38, org.Mm.eg.db,
org.Hs.eg.db, annotables, rBLAST, rentrez, clusterProfiler)
# nolint end
```

```{r PATH_DECLARATION, echo=FALSE, message=FALSE, warning=FALSE}
# nolint start
PROJECT     <- paste0("/home/daniele/Desktop/IV_course/II_semester/TF_analysis/")
BIGBEDS     <- paste0(PROJECT, "Input/BigBed/")
BEDS        <- paste0(PROJECT, "Input/BED/")
MMUSCULUS   <- paste0(BEDS, "Mouse/")
HSAPIENS    <- paste0(BEDS, "Human/")
INTER_FILES <- paste0(PROJECT, "Intermediate_data/")
SCRIPTS     <- paste0(PROJECT, "Scripts/")
RESULTS     <- paste0(INTER_FILES, "Generated_files")
FASTAS      <- paste0(INTER_FILES, "FASTA/")
FIGURES     <- paste0(PROJECT, "Figures/")

SAMPLES     <- read.csv(file = paste0(INTER_FILES, "sample_key.csv"))
DATABASES   <- paste0(PROJECT, "Databases/")
# nolint end
```

```{r FUNCTION_SOURCING, echo=FALSE, message=FALSE, warning=FALSE}
source(paste0(SCRIPTS, "functions.R"))
source(paste0(SCRIPTS, "plots.R"))
```

```{r BIGBED_READING, echo=FALSE, message=FALSE, warning=FALSE}
# nolint start
# Listing sample BigBed files for each analyzed organism:
bbfiles_mm <- list.files(path = MMUSCULUS, "*bed")
bbfiles_hg <- list.files(path = HSAPIENS, "*bed")

# Making a granges list for each analyzed organism:
grl_mm <- GRangesList()
grl_hg <- GRangesList()

chr_abr <- c(paste0("chr", 1:19), "chrX", "chrY")
len_mm <- length(bbfiles_mm)    # Length of samples for Mus musculus
len_hg <- length(bbfiles_hg)    # Length of samples for Homo sapiens

# Creating GRanges objects and extracting certain chromosomes for Mus musculus:
# for (i in 1:len_mm) {
#     grl_mm[[i]] <-
#         import(paste0(MMUSCULUS, bbfiles_mm[i])) %>%
#         dplyr::filter(seqnames %in% chr_abr)
#     names(grl_mm)[i] <- SAMPLES$Graph_names[SAMPLES$Filename == bbfiles_mm[i]]
# }

# # Creating GRanges objects and extracting certain chromosomes for Homo sapiens.
# # These files will be used as control samples to check whether TF binding sites
# # were predicted successfully using Homo sapiens annotation:
# for (i in 1:len_hg) {
#     grl_hg[[i]] <-
#         import(paste0(HSAPIENS, bbfiles_hg[i])) %>%
#         dplyr::filter(seqnames %in% chr_abr)
#     names(grl_hg)[i] <- SAMPLES$Graph_names[SAMPLES$Filename == bbfiles_hg[i]]
# }






bigbed_files <- list()
      for(rows in 1:len_mm) {
        bigbed_files[[rows]] <-
          read.table(file = paste0(MMUSCULUS, bbfiles_mm[rows]))
        colnames(bigbed_files[[rows]]) <-
          c("seqnames", "start", "end", "name", "abs_summit", "pileup",
              "p_value", "fold_enrichment", "q_value", "ID")

        grl_mm[[rows]] <- makeGRangesFromDataFrame(bigbed_files[[rows]],
                                                keep.extra.columns = TRUE)
      }
bigbed_files <- list()
      for(rows in 1:len_hg) {
        bigbed_files[[rows]] <-
          read.table(file = paste0(HSAPIENS, bbfiles_hg[rows]))
        colnames(bigbed_files[[rows]]) <-
          c("seqnames", "start", "end", "name", "abs_summit", "pileup",
              "p_value", "fold_enrichment", "q_value", "ID")

        grl_hg[[rows]] <- makeGRangesFromDataFrame(bigbed_files[[rows]],
                                                keep.extra.columns = TRUE)
      }




       
        rownames(pwm) <- c("A", "C", "G", "T")

        peak_sequences <- list()

        for (file in 1:length(grl_mm)) {
          peak_sequences[[1]] <-
            getSeq(BSgenome.Mmusculus.UCSC.mm10, grl_mm[[1]])
          names(peak_sequences)[1] <- "A"
        }

        tbx5_motifs <- data.frame(matrix(nrow = 0, ncol = 4))
        colnames(tbx5_motifs) <-
          c("Sample", "Motif_count", "Peak_count", "Percentage")

        for (i in 1:length(peak_sequences)) {
        #   filename <- input$bigbed[[i, 'datapath']]
          name <- substring(names(peak_sequences[i]), 1, 11)

          motif <- find_motif_hits(peak_sequences[[i]], pwm)
          peaks <- calculate_peaks(paste0("/home/daniele/Desktop/IV_course/II_semester/TF_analysis/Input/BED/Mouse/","PEAKS035687_Tbx5_P70326_MACS2_437.bed"))
          percentage <- round((motif / peaks) * 100, 2)

          data_row <- c(name, motif, peaks, as.numeric(percentage))
          tbx5_motifs[nrow(tbx5_motifs) + 1, ] <- data_row
        }

        # Reading a file that stores information about Tbx5 motif counts and
        # peak percentages:
        motif_data <- tbx5_motifs

        # Calling factor() function in order to maintain certain Sample
        # order:
        motif_data$Sample <-
                factor(motif_data$Sample, levels = motif_data$Sample)

        # 'Melting' the dataframe:
        melted_df <- melt(motif_data, id = c("Sample", "Percentage"))


        ggplot(melted_df, aes(fill = variable, y = as.numeric(value), x = Sample)) + 
    geom_bar(width = 0.4, size = 0.2, colour = "#3f2704", stat = 'identity',
             position = position_dodge(0.4)) +
          scale_fill_manual(values = c("#e3a15e", "#c7633b"),
                            labels = c("Tbx5 motyvų skaičius",
                                       "Pikų skaičius")) +
          scale_y_continuous(labels = label_number(suffix = " K",
                                                   scale = 1e-3)) +
           geom_text(aes(label = ifelse(variable == "Motif_count",
                                 paste0(round(as.numeric(Percentage),
                                              digits = 2), "%"), ""),
              fontface = 2), vjust = 3.2, hjust = -0.3, size = 5) +                                        
          guides(fill = guide_legend(title = "Spalvų paaiškinimas", size = 6)) +
          labs(title = "", x = "", y = "TF/Pikų skaičius") +
          theme(axis.text = element_text(size = 10, colour = "black"),
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1,
                                       size = 12, face = "bold"),
            axis.text.y = element_text(size = 12, face = "bold"),
            axis.title.x = element_text(size = 14, colour = "black"),
            axis.title.y = element_text(size = 14, colour = "black"),
            panel.grid.major = element_line(color = "#eeeeee"),
            plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
            panel.background = element_rect(fill = "#eeeef1",
                                            colour = "#4c0001"),
            panel.grid.major.y = element_line(colour = "#cab5b5",
                                              size = 0.3, linetype = "dashed"),
            panel.grid.minor.y = element_line(colour = "#cab5b5",
                                              size = 0.3, linetype = "dashed"),
            panel.grid.major.x = element_line(colour = "#cab5b5",
                                              size = 0.2, linetype = "longdash"),
            panel.grid.minor.x = element_line(colour = "#cab5b5",
                                              size = 0.2, linetype = "longdash"),
            legend.title = element_text(size = 12),
            legend.text = element_text(size = 11))+
            coord_flip()
      }





# nolint end
```

```{r PWM_READING, echo=FALSE, message=FALSE, warning=FALSE}
# nolint start
# Making a list of analyzed TF PWM matrices from different organisms:
pwm <- get_PWM("TBX5_MOUSE.H11MO.0.D.pwm")
# nolint end
```

```{r MM_PEAK_ANNOTATION, echo=FALSE, message=FALSE, warning=FALSE, output=FALSE}
# nolint start

grl_mm[[1]]

significant_peaks <- grl_mm[[1]][grl_mm[[1]]$q_value < 2, ] %>% list(.)

mm_annotated_peaks <-
    annotate_peaks(grl_mm, grcm38, TxDb.Mmusculus.UCSC.mm10.knownGene,
                   "org.Mm.eg.db")

write.table(mm_annotated_peaks,
            file = paste0(RESULTS, "/mm_annotated_peaks.txt"), sep = "\t",
            quote = FALSE, row.names = FALSE)
# nolint end
```

```{r HS_PEAK_ANNOTATION, echo=FALSE, message=FALSE, warning=FALSE, output=FALSE}
# nolint start
# Getting the peaks that are significant. q value must be lower than 2
# (-log10(0.01) = 2):
# significant_peaks <- grl_hg[[1]][grl_hg[[1]]$q_value < 2, ] %>% list(.)

# e <- names(seqlengths(significant_peaks[[1]])) %in% names(seqlengths(TxDb.Hsapiens.UCSC.hg38.knownGene))
# f <- mixedsort(seqlengths(significant_peaks[[1]])[e])
# g <- mixedsort(seqlengths(TxDb.Hsapiens.UCSC.hg38.knownGene)[d])

# F <- as.data.frame(f)
# G <- as.data.frame(g)

# seqlengths(significant_peaks[[1]])[e][order(names(seqlengths(significant_peaks[[1]])[e]))] <- g[order(names(g))]

# genome(grl_hg)
# genome(TxDb.Hsapiens.UCSC.hg38.knownGene)


hg_annotated_peaks <-
    annotate_peaks(grl_hg, grch38, TxDb.Hsapiens.UCSC.hg38.knownGene, "org.Hs.eg.db")

write.table(hg_annotated_peaks,
            file = paste0(RESULTS, "/hg_annotated_peaks.txt"), sep = "\t",
            quote = FALSE, row.names = FALSE)
# nolint end
```

```{r NUCLEOTIDE_TO_AMINOACIDS, echo=FALSE, message=FALSE, warning=FALSE, output=FALSE}
# nolint start
mmgene_ranges <- genes(TxDb.Mmusculus.UCSC.mm10.knownGene)

# Adding 'gene_symbol' column to gene_ranges GRange:
mmgene_ranges$gene_symbol <-
    mapIds(org.Mm.eg.db, keys = mmgene_ranges$gene_id, column = "SYMBOL",
           keytype = "ENTREZID", multiVals = "first")

mm_genes <- GRangesList()

for (sample in seq_along(mm_annotated_peaks)) {
    selected_genes <-
        tolower(unique(mm_annotated_peaks[[sample]]$gene_symbol)) %in%
        tolower(mmgene_ranges$gene_symbol)
                            
    genes <- mmgene_ranges[selected_genes]
    mm_genes[[sample]] <- genes 
}

# Čia išgaunamos nukleotidų sekos konkretiems genams:
gene_sequences <- getSeq(BSgenome.Mmusculus.UCSC.mm10, mm_genes[[1]])

library(ensembldb)
library(EnsDb.Mmusculus.v79)
library(deepredeff)

edb <- EnsDb.Mmusculus.v79

all_proteins <- character()
gprotein_sequences <- data.frame(matrix(ncol = 2, nrow = 0))

for (gene_name in 1:length(unique(mm_genes[[1]]$gene_symbol))) {
    gene <- mm_genes[[1]]$gene_symbol[[gene_name]]

    length(mm_genes[[1]]$gene_symbol)
    length(unique(mm_genes[[1]]$gene_symbol))

    if (is.na(gene)) {
        next
    } else {
        proteins <- proteins(edb, filter = GeneNameFilter(gene),
                     return.type = "AAStringSet")

        if (length(proteins) == 0) {
        next
    } else {
        print(paste("Getting sequence for", gene, "..."))
        proteins_df <- aas_to_df(proteins)
        proteins_df$name <- gene

        for (s in 1:length(proteins_df$seq)) {
            row <- c(gene, proteins_df$seq[s]) # Pataisymas, kad imtų viską, o ne tik pirmą seką
            gprotein_sequences[nrow(gprotein_sequences) + 1, ] <- row

            all_proteins <- append(all_proteins, proteins[s])
        }

        proteins_df <- c()
    }
    }
    
}

length(all_proteins)

sink(paste0(PROJECT, "aa_sequences_80.txt"))
print(gprotein_sequences)
sink()

# nolint end
```

Su Blast surandame Homo sapiens genus, kurie yra panašūs į Mus musculus
genus (sekų identiškumas = 60).

Sudarome lentelę, kurioje nurodytas Mus musculus genas ir jo ID bei jo
Blast atitikmuo - genas ir jo ID.


```{r BLAST_SEARCH, echo=FALSE, message=FALSE, warning=FALSE}
# nolint start
# Loading downloaded Homo sapiens protein database:
human_db <-
    blast(db = paste0(DATABASES,
          "Homo_sapiens_protein/GCF_000001405.38_GRCh38.p12_protein.fna"),
          type = "blastp")

# Performing blastp search using defined Homo sapiens protein database and
# 'AAStringSet' object that contains protein sequences of annotated genes:
predictions <-
    predict(human_db, all_proteins, BLAST_args = "-num_threads 10")

# Saving blastp result into a file so that it can be used for further analysis:
# FIND BETTER WAY TO SAVE THE RESULT!
sink(paste0(PROJECT, "predictions_protein.txt"))
print(predictions)
sink()

# Reading a file that stores blastp result:
predictions <- read.table(paste0(PROJECT, "predictions_p.txt"))
predictions <- predictions[predictions$`Perc.Ident` > 50, ] #50, 60, 70

grouped_predictions <-
    predictions %>%
    group_by(QueryID) %>%
    dplyr::filter(`Perc.Ident` == max(`Perc.Ident`)) %>%
    as.data.frame()

proteins_symbols <-
    ensembldb::select(EnsDb.Mmusculus.v79, keys = grouped_predictions$`QueryID`,
                      keytype = "PROTEINID", columns = c("ENTREZID", "SYMBOL"))

merged_data <-
    merge(proteins_symbols, grouped_predictions,
          by.x = "PROTEINID", by.y = "QueryID") %>%
    dplyr::select(c("PROTEINID", "ENTREZID", "SYMBOL",
                    "SubjectID", "Perc.Ident"))

# Removing '.[1-9]' from accession numbers (if the step is skipped the
# following function 'bitr()' does not return any results):
merged_data$SubjectID <-
    merged_data$SubjectID %>%
    gsub("\\.[1-9]+", "", .)

# Accessing Entrez identification numbers and gene symbols for every
# accession number (some accession numbers do not have Entrez id, therefore
# they are not matched):
entrezs_symbols <-
    bitr(merged_data$SubjectID, fromType = "ACCNUM",
         toType = c("ENTREZID", "SYMBOL"), OrgDb = org.Hs.eg.db)

# Creating a final dataframe that matches all subject and query data:
matched_data <-
    merge(merged_data, entrezs_symbols, by.x = "SubjectID", by.y = "ACCNUM") %>%
    rename("QueryID" = "PROTEINID", "EntrezQuery" = "ENTREZID.x",
           "QuerySymbol" = "SYMBOL.x", "EntrezSubject" = "ENTREZID.y",
           "SubjectSymbol" = "SYMBOL.y", "PercentIdentity" = "Perc.Ident") %>%
    dplyr::select(c("SubjectID", "QueryID", "SubjectSymbol", "QuerySymbol",
                    "EntrezSubject", "EntrezQuery", "PercentIdentity"))

# nolint end
```

```{r}
# nolint start
matched_data <- matched_data[!(is.na(matched_data$EntrezQuery)), ]
hggene_ranges <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)

mm_sequences <- character()
hg_sequences <- character()

for (id in 1:length(matched_data$EntrezQuery)) {
    seq_m <- getSeq(BSgenome.Mmusculus.UCSC.mm10,
                    mmgene_ranges[mmgene_ranges$gene_id ==
                                  matched_data$EntrezQuery[id], ])

    if (length(seq_m) == 0) { next }
    else {
        names(seq_m) <- matched_data[id, "QuerySymbol"]
        mm_sequences <- append(mm_sequences, seq_m)
    }

    seq_h <- getSeq(BSgenome.Hsapiens.UCSC.hg38,
                    hggene_ranges[hggene_ranges$gene_id ==
                                  matched_data$EntrezSubject[id], ])

    if (length(seq_h) == 0) { next }
    else {
        names(seq_h) <- matched_data[id, "SubjectSymbol"]
        hg_sequences <- append(hg_sequences, seq_h)
    }
}



countPWM(as.matrix(pwm), as.character(hg_sequences[[8]]), min.score = "60%")
# nolint end
```


```{r}
# nolint start
percentages <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(percentages) <- c("QueryGene", "SubjectGene", "QueryPWMHits",
                           "SubjectPWMHits", "Percent")


for (gene in 1:length(mm_sequences)) {
    mm_hits <-
        as.numeric(countPWM(as.matrix(pwm), as.character(mm_sequences[[gene]]),
                            min.score = "60%"))

    hg_hits <-
        as.numeric(countPWM(as.matrix(pwm), as.character(hg_sequences[[gene]]),
                            min.score = "60%"))

    row <- c(names(mm_sequences[gene]), names(hg_sequences[gene]),
             mm_hits, hg_hits, (mm_hits / hg_hits) * 100)

    percentages[nrow(percentages) + 1, ] <- row            
}

percentages$SubjectGene %in% hg_annotated_peaks[[1]]$gene_symbol



# nolint end
```




































Čia yra tikrinama, kaip veikia GO analizės:
```{R}
library(DOSE)


# barplot(ego, showCategory=50)
# library(enrichplot)

# grl_mm[[1]]$fold_enrichment


# data(geneList)
# # de <- names(geneList)[abs(geneList) > 2]


# PRATĘSTI NUO ČIA... REIKIA PERDARYTI GRanges OBJEKTUS, KAD
# BŪTŲ `Fold Enrichment`, `Gene Symbol` ir `Gene ID`.
##########################################################################
# de <- mm_annotated_peaks
# de <- grl_mm[[1]]$fold_enrichment[abs(grl_mm[[1]]$fold_enrichment) > 2]


# The following piece of code is OK and can the used:
###################################################################
merged_expanded <- list()

for (l in 1:length(grl_mm)) {
    merged_data <- merge(mm_annotated_peaks[[l]], grl_mm[[l]])
    expanded_merged <-
        bitr(merged_data$gene_symbol, fromType = "SYMBOL",
             toType = c("ENTREZID"), OrgDb = org.Mm.eg.db)
    merged_expanded[[l]] <-
        merge(merged_data, expanded_merged, by.x = "gene_symbol",
              by.y = "SYMBOL", all.x = TRUE) %>%
        as.data.frame() %>%
        makeGRangesFromDataFrame(., keep.extra.columns = TRUE)
}
###################################################################

row1 <- as.numeric(merged_expanded[[1]]$ENTREZID)
data.frame(matrix(ncol = 2, nrow = 0))
row2 <- as.numeric(merged_expanded[[1]]$fold_enrichment)

mat <- t(as.matrix(data.frame(row1, row2)))

rownames(mat) <- NULL
colnames(mat) <- NULL

library(DOSE)
data(geneList)

library(enrichplot)
plots <- list()

for (me in 1:length(merged_expanded)) {

          row1 <- as.numeric(merged_expanded[[me]]$ENTREZID)

          row2 <- as.numeric(merged_expanded[[me]]$fold_enrichment)

          mat <- t(as.matrix(data.frame(row1, row2)))
          rownames(mat) <- NULL
          colnames(mat) <- NULL

          plots[[me]] <-
            enrichGO(gene = merged_expanded[[me]]$ENTREZID,
                                  OrgDb = org.Mm.eg.db, ont = "CC",
                                  pAdjustMethod = "BH", pvalueCutoff  = 0.01,
                                  qvalueCutoff  = 0.05, readable = TRUE)
        }
        ggarrange(plotlist = plots)

a <- enrichGO(gene          = merged_expanded[[1]]$ENTREZID,
                OrgDb         = org.Mm.eg.db,
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)

goplot(a)

head(a)
colnames(a)

a <- as.data.frame(a)
head(a)
colnames(a)

rownames(a)

head(a, dim(a)[1])


b <- head(a)

b$Status <- "Peržiūrėti sąrašą..."
b

as.data.frame(b)

genes <- b[3,"geneID"]
genes

n <- strsplit(genes, split = "/")

va <- as.data.table(n)
n
length(rownames(n))




g <- length(unlist(n)) %/% 6
g

c <- 17 %/% 5
d <- 17 - 5 * c

e <- 5 - d
e


floor(g)

6 - (length(unlist(n)) - 6 * length(unlist(n)) %/% 6)

l <- unlist(n)

l <- c(l, rep("", 6 - (length(l) - 6 * (length(l) %/% 6))))


vec <- 1:15
mat <- matrix(l, ncol = 6)
mat


as.data.table(mat, ncol= 6)
colnames(b)
length(dim(a))


genes <- unlist(strsplit(pl$geneID, split = "/")[value])
genes <- c(genes, rep("", 6 - (length(genes) - 6 * length(genes) %/% 6)))
                  tb <- matrix(genes, ncol = 6)



print(a)
a <- pairwise_termsim(a)
emapplot(a)

edo <- enrichDGN(merged_expanded[[1]]$ENTREZID)

barplot(a, showCategory=20) 

edox <- setReadable(a, 'org.Mm.eg.db', 'ENTREZID')


p1 <- heatplot(edox, showCategory=10)
p2 <- heatplot(edox, foldChange=merged_expanded[[1]]$fold_enrichment, showCategory=10)
cowplot::plot_grid(p1, p2, ncol=1, labels=LETTERS[1:2])


edox2 <- pairwise_termsim(edox)
p1 <- treeplot(edox2)
p2 <- treeplot(edox2, hclust_method = "average")
aplot::plot_list(p1, p2, tag_levels='A')


xx <- compareCluster(gcSample, fun="enrichKEGG",
                     organism="mmu", pvalueCutoff=0.05)
xx <- pairwise_termsim(edox)                     
p1 <- emapplot(edox)
p2 <- emapplot(edox, legend_n=2) 
p3 <- emapplot(edox, pie="count")
p4 <- emapplot(edox, pie="count", cex_category=1.5, layout="kk")
cowplot::plot_grid(p1, p2, p3, p4, ncol=2, labels=LETTERS[1:4])




p1 <- cnetplot(edox, foldChange=merged_expanded[[1]]$fold_enrichment, node_label="gene", 
        cex_label_gene = 0.8)
## categorySize can be scaled by 'pvalue' or 'geneNum'
p2 <- cnetplot(edox, categorySize="pvalue", foldChange=merged_expanded[[1]]$fold_enrichment)
p3 <- cnetplot(edox, foldChange=merged_expanded[[1]]$fold_enrichment, circular = TRUE, colorEdge = TRUE) 
cowplot::plot_grid(p1, p2, p3, ncol=3, labels=LETTERS[1:3], rel_widths=c(.8, .8, 1.2))

p1


















library(DOSE)
data(geneList)
de <- names(geneList)[abs(geneList) > 2]







write.table(mat, paste0(PROJECT, "mat.csv"), col.names=FALSE, row.names=FALSE, sep = ",")



ego <- enrichGO(gene = as.numeric(merged_expanded[[1]]$ENTREZID), 
                    keyType = "ENTREZID", 
                    OrgDb = org.Mm.eg.db, 
                    ont = "BP", 
                    pAdjustMethod = "BH", 
                    qvalueCutoff = 0.05, 
                    readable = TRUE)


dotplot(ego, showCategory=50)

head(ego$Count)

colnames(ego)

class(ego)

ego <- as.data.frame(ego)

colnames(as.data.frame(ego))

barplot(ego, showCategory=50)

# barplot(ego[order(ego[,9],decreasing=TRUE),][,9], showCategory=50)








head(mat)

library("pathview")

barplot(mat, showCategory=10)

hsa04110 <- pathview(gene.data  = mat,
                     pathway.id = "mmu05022",
                     species    = "mmu",
                     limit      = list(gene=max(abs(mat), na.rm = TRUE), cpd=1))


kk <- enrichKEGG(gene         = mat,
                 organism     = 'mmu',
                 pvalueCutoff = 0.05)

geneList

browseKEGG(kk, 'mmu04010')

head(kk)

kk2 <- gseKEGG(geneList     = merged_expanded[[1]]$ENTREZID,
               organism     = 'mmu',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
##########################################################################

edo <- enrichDGN(merged_expanded[[1]]$ENTREZID)
edox <- setReadable(edo, 'org.Hs.eg.db', 'ENTREZID')
p1 <- cnetplot(edox, foldChange=geneList)

p1 <- heatplot(edox, showCategory=5)
p2 <- heatplot(edox, foldChange=geneList, showCategory=5)
cowplot::plot_grid(p1, p2, ncol=1, labels=LETTERS[1:2])

edox2 <- pairwise_termsim(edox)
p1 <- treeplot(edox2)
p2 <- treeplot(edox2, hclust_method = "average")
aplot::plot_list(p1, p2, tag_levels='A')

library(ggridges)
edo2 <- gseDO(geneList)
ridgeplot(edo2)

#########################################

library(DOSE)
data(geneList)
gene <- names(geneList)[abs(geneList) > 1.5]

length(genes)

search_kegg_organism('Mus musculus', by='scientific_name')

kegg <- enrichKEGG(gene = genes,
                 organism = 'mmu',
                 pvalueCutoff = 0.05)

head(kegg)

enrichDO(gene          = gene,
              ont           = "DO",
              pvalueCutoff  = 0.05,
              pAdjustMethod = "BH",
              universe      = names(geneList),
              minGSSize     = 5,
              maxGSSize     = 500,
              qvalueCutoff  = 0.05,
              readable      = FALSE)


enrichDO(gene          = genes,
              ont           = "DO",
              pvalueCutoff  = 0.05,
              pAdjustMethod = "BH",
              qvalueCutoff  = 0.05,
              readable      = FALSE)

sink(paste0(PROJECT, "rez.txt"))
print(head(as.data.frame(ggo)))
sink()
```







